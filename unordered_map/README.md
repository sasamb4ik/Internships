На этот раз нужно будет правильно поддержать не только итераторы и аллокаторы, но еще и move-семантику. Все классы, которые вы используете для своей реализации UnorderedMap (например, List), также должны корректно поддерживать move-семантику. В частности, вам нужно дописать поддержку move-семантики в List, если ранее он ее не поддерживал.

Напишите шаблонный класс UnorderedMap<Key, Value, Hash, Equal, Alloc> - упрощенный аналог std::unordered_map. Здесь Key - тип ключа, Value - тип значения, Hash - используемая хеш-функция (по умолчанию std::hash<Key>, реализовывать hash не надо), Equal - используемый сравниватель (по умолчанию - std::equal_to<Key>), Alloc - используемый аллокатор (по умолчанию - std::allocator<std::pair<const Key, Value»).

Типы Key и Value не обязаны иметь конструкторы по умолчанию, копирующий конструктор и копирующий оператор присваивания. Для создания UnorderedMap с ними должно быть достаточно, чтобы они имели лишь move-конструктор и move-оператор присваивания.

Внутри UnorderedMap публично определим тип NodeType как std::pair<const Key, Value>. (В std::unordered_map аналогичный тип называется value_type.)

Должна быть реализована следующая функциональность:

* Конструкторы (в т.ч. копирования и перемещения), деструктор, копирующий и перемещающий операторы присваивания.
* Методы [] и at(key), работающие в среднем за O(1). Метод [] определен только для неконстантных объектов, он создает Value по умолчанию, если по данному ключу ничего не было. Метод at(key) в таком случае кидает исключение. Если в метод [] передано rvalue и оказалось, что такого ключа в мэпе не было, то нужно эффективно создать Node с таким ключом: не копировать его, а перемещать.
* Метод size(), за O(1) возвращающий текущее количество элементов в контейнере.
* Внутренние типы iterator и const_iterator, удовлетворяющие требованиям ForwardIterator. Разыменование константного итератора не должно позволять поменять объект под ним.
* Методы begin(), end(), cbegin(), cend(). Итераторы должны быть реализованы так, чтобы код for (auto it = m.begin(); it != m.end(); ++it); позволял пройтись по всем лежащим в контейнере элементам за линейное время от количества этих элементов (а не от размера хеш-таблицы). Инкрементация любого итератора должна происходить за гарантированное O(1).
* Метод insert, принимающий ссылку на NodeType и возвращающий pair<iterator, bool>, где bool означает “произошла ли вставка”, а iterator указывает на элемент с данным ключом в контейнере (либо уже лежавший там, либо только что вставленный). Метод insert должен эффективно обрабатывать как lvalue, так и rvalue: не копировать переданную ему NodeType, если она была rvalue! Вставка элемента должна работать за O(1) в среднем.
* Метод insert от пары InputIterator’ов на NodeType, делающий вставку всего данного диапазона в контейнер. Кстати, разыменование итератора необязательно дает lvalue, оно может давать и rvalue-ссылку. Например, так ведет себя std::move_iterator. В таком случае вы должны вставлять элементы из-под этого итератора в UnorderedMap не копированием, а перемещением.
* Метод emplace(Args&&... args), который самостоятельно конструирует NodeType от переданных аргументов (без их копирования, если это возможно) и, не копируя, вставляет полученный объект NodeType в контейнер, если это возможно. Возвращаемый тип - такой же, как у insert от NodeType.
* Метод erase от итератора, а также от пары итераторов (удаляющие один элемент и диапазон элементов соответственно). Итераторы на элементы, которые не были удалены, должны не инвалидироваться после вызова erase. Удаление одного элемента должно работать за O(1) в среднем.
* Метод find по ключу, возвращающий итератор на найденный элемент или end(), если элемент не был найден. Поиск должен работать в среднем за O(1).
* Методы reserve, load_factor и max_load_factor, аналогичные методам STL, позволяющие управлять размером хеш-таблицы.
* Метод swap с другим UnorderedMap. Должен работать за O(1). При swap итераторы в обоих UnorderedMap не должны инвалидироваться, а должны продолжать указывать на те же элементы, куда указывали ранее.
Вставка и удаление любого количества элементов в UnorderedMap не должны инвалидировать указатели и ссылки на остальные элементы UnorderedMap'а (то есть на NodeType). Однако вставка может инвалидировать итераторы, если во время нее произошел rehash.

Методы insert и emplace, вставляющие одиночные элементы, должны быть строго безопасны относительно исключений, кроме случая, когда исключение кидается хеш-функцией.

Как и List, UnorderedMap должен быть allocator-aware контейнером. Никаких прямых обращений к new/delete быть не должно, всё должно происходить через allocator_traits. Во время конструирования и присваивания UnorderedMap'ов должны правильно использоваться свойства и методы аллокаторов select_on_container_copy_construction, propagate_on_container_copy_assignment, propagate_on_container_move_assignment, propagate_on_container_swap.

Если аллокатор является структурой без каких-либо полей, то такой аллокатор не должен увеличивать sizeof объекта UnorderedMap. То есть тривиальный аллокатор как поле UnorderedMap должен занимать 0 байт. То же самое требование распространяется и на объект Hash, и на объект Equal.

В вашем файле должна отсутствовать функция main(), а сам файл должен называться unordered_map.h. Ваш код будет вставлен посредством команды #include "unordered_map.h" в программу, содержащую тесты; вследствие этого, код необходимо отправлять в файле со строго соответствующим именем!
